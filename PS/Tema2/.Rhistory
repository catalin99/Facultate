G = G[-muchieRand[2], ]; #eliminam al doilea nod(selectat aleatoriu) din graf
G = G[, -muchieRand[2]];
}
return (G[1,2]); #numarul minim de taieturi pentru a avea 2 componente conexe disjuncte
}
matrice = matrix(c(0,1,1,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0), 6, 6)#matricea de adiacenta din problema
KargerAlg(matrice)
KargerAlg = function(G) #dam ca parametru o matrice G
{
while(nrow(G)>2)  #eliminam muchii pana graful mai are doar 2
{
muchieRand = sample(1:nrow(G), 2, replace=T);
while(G[muchieRand[1], muchieRand[2]] == 0) #Selectam 2 noduri care au muchii intre ele
{
muchieRand = sample(1:nrow(G), 2, replace=T);
}
for(i in 1:ncol(G)) #combinam cele 2 noduri ramase intr-un multi-graf #contractare
{
if(G[muchieRand[2], i] > 0 & i != muchieRand[1])
{
G[muchieRand[1], i] = G[muchieRand[1],i] + G[muchieRand[2],i];
G[i, muchieRand[1]] = G[muchieRand[1],i];
}
}
G = G[-muchieRand[2], ]; #eliminam al doilea nod(selectat aleatoriu) din graf
G = G[, -muchieRand[2]];
}
return (G[1,2]); #numarul minim de taieturi pentru a avea 2 componente conexe disjuncte
}
matrice = matrix(c(0,1,1,0,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,1,0,1,1,0), 6, 6)#matricea de adiacenta din problema
KargerAlg(matrice)
Volum_Elipsoid=function(n) #trebuie sa rezolvam folosind monte carlo
{             #si sa comparam rezultatul generat de algoritm cu cel corect (eroarea)
N_C=0;
for(i in 1:n)
{
x=runif(1,-2,2);
y=runif(1,-3,3);
z=runif(1,-4,4);
if((x*x/4)+(y*y/9)+(z*z/16)<=1)
N_C=N_C+1;
}
return (8*6*4*N_C/n);
}
Volum_Elipsoid=function(n) #trebuie sa rezolvam folosind monte carlo
{             #si sa comparam rezultatul generat de algoritm cu cel corect (eroarea)
N_C=0;
for(i in 1:n)
{
x=runif(1,-2,2);
y=runif(1,-3,3);
z=runif(1,-4,4);
if((x*x/4)+(y*y/9)+(z*z/16)<=1)
N_C=N_C+1;
}
return (8*6*4*N_C/n);
}
CalculErori = function(valMC, valActual)
{
errAbs = abs(valMC - valActual)
errRel = errAbs/valActual
return(errRel)
}
PI=3.14159265358
VolumActual=PI*2*3*4*4/3
print("Volumul elipsoidului actual este:")
print(VolumActual)
Volum_Elipsoid=function(n) #trebuie sa rezolvam folosind monte carlo
{             #si sa comparam rezultatul generat de algoritm cu cel corect (eroarea)
N_C=0;
for(i in 1:n)
{
x=runif(1,-2,2);
y=runif(1,-3,3);
z=runif(1,-4,4);
if((x*x/4)+(y*y/9)+(z*z/16)<=1)
N_C=N_C+1;
}
return (8*6*4*N_C/n);
}
CalculErori = function(valMC, valActual)
{
errAbs = abs(valMC - valActual)
errRel = errAbs/valActual
return(errRel)
}
PI=3.14159265358
VolumActual=PI*2*3*4*4/3
print("Volumul elipsoidului actual este:")
print(VolumActual)
v1 = Volum_Elipsoid(10000)
print(v1)
print(CalculErori(v1,VolumActual))
Volum_Elipsoid=function(n) #trebuie sa rezolvam folosind monte carlo
{             #si sa comparam rezultatul generat de algoritm cu cel corect (eroarea)
N_C=0;
for(i in 1:n)
{
x=runif(1,-2,2);
y=runif(1,-3,3);
z=runif(1,-4,4);
if((x*x/4)+(y*y/9)+(z*z*z/16)<=1)
N_C=N_C+1;
}
return (8*6*4*N_C/n);
}
CalculErori = function(valMC, valActual)
{
errAbs = abs(valMC - valActual)
errRel = errAbs/valActual
return(errRel)
}
PI=3.14159265358
VolumActual=PI*2*3*4*4/3
print("Volumul elipsoidului actual este:")
print(VolumActual)
v1 = Volum_Elipsoid(10000)
print(v1)
print(CalculErori(v1,VolumActual))
v2 = Volum_Elipsoid(20000)
print(v2)
print(CalculErori(v2,VolumActual))
v3 = Volum_Elipsoid(50000)
print(v3)
print(CalculErori(v3,VolumActual))
Volum_Elipsoid=function(n) #trebuie sa rezolvam folosind monte carlo
{             #si sa comparam rezultatul generat de algoritm cu cel corect (eroarea)
N_C=0;
for(i in 1:n)
{
x=runif(1,-2,2);
y=runif(1,-3,3);
z=runif(1,-4,4);
if((x*x/4)+(y*y/9)+(z*z*z/16)<=1)
N_C=N_C+1;
}
return (8*6*4*N_C/n);
}
CalculErori = function(valMC, valActual)
{
errAbs = abs(valMC - valActual)
errRel = errAbs/valActual
return(errRel)
}
PI=3.14159265358
VolumActual=PI*2*3*4*4/3
print("Volumul elipsoidului actual este:")
print(VolumActual)
v1 = Volum_Elipsoid(10000)
print(v1)
print(CalculErori(v1,VolumActual))
Integrala1 = function(n) #monte carlo+comparatie cu rezultat corect
{
suma = 0
for(i in 1:n)
{
x = runif(1,0,1)
suma = suma + (cos(50*x) + sin(20*x))^2
}
return (suma/n)
}
Integrala2 = function(n)
{
suma = 0
for(i in 1:n)
{
x = runif(1,0,3)
suma = suma + (x^3)/(x^4+1)
}
return (3*suma/n)
}
Integrala2Actual = 1.10168
print(Integrala2Actual)
print(Integrala2(100000))
EstimareTimpMediu = function(n)
{
suma = 0
for(i in 1:n)
{
server1 = rgamma(1,shape=5,scale=3) #generare random pentru gama in functie de shape si scale
server2 = rgamma(1,shape=7,scale=5) #shape, scale - distributia
server3 = rgamma(1,shape=5,scale=2)
x = rexp(1,1) #distributia exponentiala
y = runif(1,0,1)#distributia uniforma
if(y >= 0.5) #directionam catre primul server
{
suma = suma + server1
}
else
{
if(y < 0.3) #directionam catre celelalte
{
suma = suma + server2
}
else
{
suma = suma + server3
}
}
suma = suma + x #adunam si latenta dintre client si server
}
return (suma/n);
}
print(EstimareTimpMediu(1000))
ConturiInfectate = function()
{
maxInfect = 1
countInfect = 1
countZile = 1
while(countInfect > 0 & countInfect < 20)
{
if(countZile >= 2)
{
countInfect = countInfect - 5 #scadem conturile infectate
}
countCurat = 20 - countInfect  #actualizam valoarea conturilor "curate"
if(countCurat > 0)
{
for(i in 1:countCurat)
{
x = runif(1,0,1)
if(x <= 0.25)
{
countInfect = countInfect + 1 #raspandirea malware-ului cu probabilitatea de 0.25
}
}
}
if(maxInfect < countInfect)
{
maxInfect = countInfect
}
countZile = countZile + 1
}
return(maxInfect)
}
print(ConturiInfectate())
#a)
InfectCelPutinOdata = function(n)
{
suma = 0
for(i in 1:n)
{
j=ConturiInfectate()
if(j >= 1){
suma = suma + j
}
}
return(suma/n)
}
print(InfectCelPutinOdata(1000))
#b)
InfectToateConturile = function(n){
suma = 0
for(i in 1:n){
if(ConturiInfectate() == 20){
suma = suma + 200
}
}
return(suma/n)
}
print(InfectToateConturile(10000))
#c)
N_minim = function(epsilon,n)
{
alfa = 1-n
z = qnorm(alfa/2)
rez = (1/4)*(z/epsilon)*(z/epsilon)
return(rez)
}
nrSimulari = 1 + N_minim(0.01, 0.99)
print(nrSimulari)
print(InfectToateConturile(nrSimulari))
zconfidence_interval=function(n,media,alfa,varianta)
{
deviatieStandard = sqrt(varianta)
critical_z = qnorm(1-alfa/2,0,1)
a = media - critical_z * deviatieStandard/sqrt(n)
b = media + critical_z * deviatieStandard/sqrt(n)
return(c(a,b))
}
zconfidence_interval(8, 2.75, 0.01, 0.25)
test_proportion = function(n,succese,alfa,p0,tip) #testul z asupra proportiilor
{#se numara succesele din n incercari
pPrim = succese / n
z_score = ( pPrim - p0 ) / sqrt( p0*(1-p0) / n)
if(tip == 1) #Ipoteza asimetrica la dreapta
{
critical_z = qnorm(1-alfa,0,1)
if(z_score < critical_z)
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
if(tip == 2) #Ipoteza asimetrica la stanga
{
critical_z = qnorm(alfa,0,1)
if(z_score > critical_z)
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
if(tip == 3) #Ipoteza simetrica
{
critical_z = -qnorm(alfa/2,0,1)
if(abs(critical_z) > abs(z_score))
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
return(c(critical_z, z_score))
}
print("Pentru alfa=0.01")
test_proportion(112, 14, 0.01, 0.1, 1)
?qnorm
zconfidence_interval=function(n,media,alfa,varianta)
{
deviatieStandard = sqrt(varianta)
critical_z = qnorm(1-alfa/2,0,1)
a = media - critical_z * deviatieStandard/sqrt(n)
b = media + critical_z * deviatieStandard/sqrt(n)
return(c(a,b))
}
zconfidence_interval(8, 2.75, 0.01, 0.25)
test_proportion = function(n,succese,alfa,p0,tip) #testul z asupra proportiilor
{#se numara succesele din n incercari
pPrim = succese / n
z_score = ( pPrim - p0 ) / sqrt( p0*(1-p0) / n)
if(tip == 1) #Ipoteza asimetrica la dreapta
{
critical_z = qnorm(1-alfa,0,1) #x, mean, dev standard
if(z_score < critical_z)
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
if(tip == 2) #Ipoteza asimetrica la stanga
{
critical_z = qnorm(alfa,0,1)
if(z_score > critical_z)
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
if(tip == 3) #Ipoteza simetrica
{
critical_z = -qnorm(alfa/2,0,1)
if(abs(critical_z) > abs(z_score))
print("Se accepta ipoteza nula")
else
print("Se respinge ipoteza nula")
}
return(c(critical_z, z_score))
}
print("Pentru alfa=0.01")
test_proportion(112, 14, 0.01, 0.1, 1)
#112 clienti, 14 nemultumiti, 0.01/0.05 nivel de semnificatie,
#0.1=10% clienti numultumiti initial
print("Pentru alfa=0.05")
test_proportion(112, 14, 0.05, 0.1, 1)
z_test=function(a,n,z_score,tip)
{#Testul Z pentru diferentta mediilor unor populattii
#cu dispersii cunoscute
if(tip==0)
{
#ipoteza simetrica
z_critical=qnorm(1-a/2,0,1)
if(abs(z_score)<abs(z_critical))
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
else
{
if(tip==1)
{
#ipoteza asimetrica la stanga
z_critical=qnorm(a,0,1)
if(z_score>z_critical)
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
else
{
#ipoteza asimetrica la dreapta
z_critical=qnorm(1-a,0,1)
if(z_score<z_critical)
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
}
return (c(z_score,z_critical))
}
print("Pentru nivelul de semnificatie 1%:")
z_test(0.01,36,-2.35,0)
print("Pentru nivelul de semnificatie 5%:")
z_test(0.05,36,-2.35,0)
z_test_means=function(a,n1,n2,x1,x2,s1,s2,tip)
{
z_score=(x1-x2)/(sqrt(s1^2/n1)+sqrt(s2^2/n2))
if(tip==0)
{
#ipoteza simetrica
z_critical=qnorm(1-a/2,0,1)
if(abs(z_score)<abs(z_critical))
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
else
{
if(tip==1)
{
#ipoteza asimetrica la stanga
z_critical=qnorm(a,0,1)
if(z_score>z_critical)
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
else
{
#ipoteza asimetrica la dreapta
z_critical=qnorm(1-a,0,1)
if(z_score<z_critical)
print("Ipoteza nula se accepta!")
else
print("Ipoteza nula se respinge!")
}
}
return (c(z_score,z_critical))
}
print("Pentru nivelul de semnificatie 1%:")
z_test_means(0.01,155,150,15,14.5,0.75,0.78,0)
print("Pentru nivelul de semnificatie 5%:")
z_test_means(0.05,155,150,15,14.5,0.75,0.78,0)
f_test=function(n1,s1,n2,s2,alfa,tip)
{
f=s1^2/s2^2
if(tip==0)
{
#ipoteza simetrica
Fs_critical=qf(alfa/2,n1-1,n2-1)
Fd_critical=qf(1-alfa/2,n1-1,n2-1)
if(f<=Fd_critical && f>=Fs_critical)
print("Ipoteza nula NU a fost respinsa!")
else
print("Ipoteza nula a fost respinsa!")
rezultat=vector()
rezultat[1]=f
rezultat[2]=Fs_critical
rezultat[3]=Fd_critical
}
else
{
#ipoteza asimetrica la dreapta
F_critical=qf(1-alfa,n1-1,n2-2)
if(f<=F_critical)
print("Ipoteza nula NU a fost respinsa!")
else
print("Ipoteza nula a fost respinsa!")
rezultat=vector()
rezultat[1]=f
rezultat[2]=F_critical
}
return (rezultat)
}
T_test_means=function(a,n1,n2,s1,s2,x1,x2,m0,tip)
{
el_curent=f_test(n1,s1,n2,s2,a,0)
if(el_curent[1]>=el_curent[2] && el_curent[1]<=el_curent[3])
ok=1  #dispersiile sunt egale
else ok=0   #dispersiile nu sunt egale
if(ok==0)
{
t_score=(x1-x2-m0)/sqrt(s1^2/n1 + s2^2/n2)
df=min(n1-1,n2-1)
}
else
{
s=((n1-1)*s1^2+(n2-1)*s2^2)/(n1+n2-2)
t_score=(x1-x2-m0)/sqrt(s/n1 + s/n2)
df=n1+n2-2
}
if(tip==0)    #ipoteza simetrica
{
t_critical=-qt(a/2,df)
if(abs(t_score)>abs(t_critical))
print("Ipoteza nula a fost acceptata!")
else
print("Ipoteza nula a fost respinsa!")
}
else if(tip==1)    #ipoteza asimetrica la stanga
{
t_critical=qt(a,df)
if(t_score>t_critical)
print("Ipoteza nula a fost acceptata!")
else
print("Ipoteza nula a fost respinsa!")
}
else if(tip==2)    #ipoteza asimetrica la dreapta
{
t_critical=qt(1-a,df)
if(t_score<t_critical)
print("Ipoteza nula a fost acceptata!")
else
print("Ipoteza nula a fost respinsa!")
}
return(c(t_score,t_critical))
}
T_test_means(0.05,66,68,1.2,1.1,21,20,0,0)
