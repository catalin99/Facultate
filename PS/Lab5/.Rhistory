eroare_absoluta = function(given,expected){
if(given>expected)return(given-expected)
else return(expected-given)
}
eroare_relativa = function(given,expected){
return(eroare_absoluta(given,expected)/expected)
}
N_minim = function(marja_eroare,probabilitate){
alfa = 1-probabilitate
z = qnorm(alfa/2)
epsilon = marja_eroare
n_min = (1/4)*(z/epsilon)^2
return(as.integer(n_min))
}
volum_sfera = function(N)
{
N_C = 0
for(i in 1:N)
{
x = runif(1, -1, 1)
y = runif(1, -1, 1)
z = runif(1, -1, 1)
if(x*x + y*y + z*z <= 1)
N_C = N_C + 1;
}
return(8*N_C/N);
}
given = volum_sfera(10000)
print(given)
eroare_absoluta(given,(pi*4)/3)
eroare_relativa(given,(pi*4)/3)
arie_elipsa = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -2, 2)
y = runif(1, -2, 2)
if(x*x + 4*y*y <= 4)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
arie_elipsa(10000)
arie_parabola = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -1, 3)
y = runif(1, 0, 4)
if((-1)*x*x + 2*x + 3 >= y)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
given = arie_parabola(100000)
print(given)
unu_a = function(n){
sum = 0
for(i in 1:n){
x = runif(1,0,pi)
sum = sum + (cos(x))^2
}
return((pi*sum)/n)
}
unu_a(10000)
unu_b = function(n){
sum = 0
for(i in 1:n){
x = runif(1,0,3)
sum = sum + exp(x)
}
return((3*sum)/n)
}
unu_b(10000)
doi_a = function(n){
sum = 0
for(i in 1:n){
x = rexp(1,1)
sum = sum + ((1/(x^2+1))/exp(-x))
}
return(sum/n)
}
doi_a(10000)
trei = function(n){
sum = 0
for(i in 1:n){
u = rexp(1,1)
sum = sum + exp(((-1)*u*u)/2)/exp(-u)
}
return(sum/n)
}
trei(40000)
nr_days = function(){
nrd = 1;
last_errors = c(11,16,18)
nr_err = 18
while(nr_err > 0){
lambda = min(last_errors)
nr_err = rpois(1,lambda)
last_errors = c(nr_err,last_errors[1:2])
nrd = nrd + 1
}
return(nrd)
}
MC_nr_days = function(n){
sum = 0
for(i in 1:n){
sum = sum + nr_days()
}
return(sum/n)
}
MC_nr_days(10000)
calc_timp = function(n){
t = 0
for(i in 1:n){
r = runif(1,0,1)
if(r <= 0.8){
t = t + rexp(1,20)
}
else{
t = t + rexp(1,5)
}
}
return(t/n)
}
calc_timp(10000)
prob1 = function(n){
counter = 0
for(i in 1:n){
x = rpois(1,3)
y = rpois(1,5)
if( x>y ){
counter = counter+1
}
}
return(counter/n)
}
prob1(10000)
prob1(1+N_minim(0.005,0.95))
infectare = function(){
max_infectate = 1
nr_infectate = 1
nr_zile = 1
while(0<nr_infectate && nr_infectate<20){
# dezinfectare
if(nr_zile > 1){
nr_infectate = nr_infectate - 2
}
#infectare
nr_curate = 20-nr_infectate
if(nr_curate > 0){
for(i in 1:nr_curate){
r = runif(1,0,1)
if(r<=0.1){
nr_infectate = nr_infectate + 1
}
}
}
#maxim calc infectate
if(max_infectate < nr_infectate)max_infectate = nr_infectate
#trecem la ziua urmatoare
nr_zile = nr_zile + 1
}
return(max_infectate)
}
prob_infectare_20 = function(n){
counter = 0
for(i in 1:n){
if(infectare() == 20){
counter = counter + 1
}
}
return(counter/n)
}
prob_infectare_8 = function(n){
counter = 0
for(i in 1:n){
if(infectare() >= 8){
counter = counter + 1
}
}
return(counter/n)
}
prob_infectare_20(100)
prob_infectare_8(1+N_minim(0.01,0.95))
eroare_absoluta = function(given,expected){
if(given>expected)return(given-expected)
else return(expected-given)
}
eroare_relativa = function(given,expected){
return(eroare_absoluta(given,expected)/expected)
}
N_minim = function(marja_eroare,probabilitate){
alfa = 1-probabilitate
z = qnorm(alfa/2)
epsilon = marja_eroare
n_min = (1/4)*(z/epsilon)^2
return(as.integer(n_min))
}
volum_sfera = function(N)
{
N_C = 0
for(i in 1:N)
{
x = runif(1, -1, 1)
y = runif(1, -1, 1)
z = runif(1, -1, 1)
if(x*x + y*y + z*z <= 1)
N_C = N_C + 1;
}
return(8*N_C/N);
}
given = volum_sfera(10000)
print(given)
eroare_absoluta(given,(pi*4)/3)
eroare_relativa(given,(pi*4)/3)
arie_elipsa = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -2, 2)
y = runif(1, -2, 2)
if(x*x + 4*y*y <= 4)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
arie_elipsa(10000)
arie_parabola = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -1, 3)
y = runif(1, 0, 4)
if((-1)*x*x + 2*x + 3 >= y)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
given = arie_parabola(100000)
print(given)
arie_elipsa = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -2, 2)
y = runif(1, -2, 2)
if(x*x + 4*y*y <= 4)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
arie_elipsa(10000)
arie_parabola = function(N){
N_C = 0
for(i in 1:N)
{
x = runif(1, -1, 3)
y = runif(1, 0, 4)
if((-1)*x*x + 2*x + 3 >= y)
N_C = N_C + 1;
}
return((4^2)*N_C/N);
}
given = arie_parabola(100000)
print(given)
unu_a = function(n){
sum = 0
for(i in 1:n){
x = runif(1,0,pi)
sum = sum + (cos(x))^2
}
return((pi*sum)/n)
}
unu_a(10000)
doi_a = function(n){
sum = 0
for(i in 1:n){
x = rexp(1,1)
sum = sum + ((1/(x^2+1))/exp(-x))
}
return(sum/n)
}
doi_a(10000)
trei = function(n){
sum = 0
for(i in 1:n){
u = rexp(1,1)
sum = sum + exp(((-1)*u*u)/2)/exp(-u)
}
return(sum/n)
}
trei(40000)
nr_days = function(){
nrd = 1;
last_errors = c(11,16,18)
nr_err = 18
while(nr_err > 0){
lambda = min(last_errors)
nr_err = rpois(1,lambda)
last_errors = c(nr_err,last_errors[1:2])
nrd = nrd + 1
}
return(nrd)
}
MC_nr_days = function(n){
sum = 0
for(i in 1:n){
sum = sum + nr_days()
}
return(sum/n)
}
MC_nr_days(10000)
calc_timp = function(n){
t = 0
for(i in 1:n){
r = runif(1,0,1)
if(r <= 0.8){
t = t + rexp(1,20)
}
else{
t = t + rexp(1,5)
}
}
return(t/n)
}
calc_timp(10000)
prob1 = function(n){
counter = 0
for(i in 1:n){
x = rpois(1,3)
y = rpois(1,5)
if( x>y ){
counter = counter+1
}
}
return(counter/n)
}
prob1(10000)
prob1(1+N_minim(0.005,0.95))
infectare = function(){
max_infectate = 1
nr_infectate = 1
nr_zile = 1
while(0<nr_infectate && nr_infectate<20){
# dezinfectare
if(nr_zile > 1){
nr_infectate = nr_infectate - 2
}
#infectare
nr_curate = 20-nr_infectate
if(nr_curate > 0){
for(i in 1:nr_curate){
r = runif(1,0,1)
if(r<=0.1){
nr_infectate = nr_infectate + 1
}
}
}
#maxim calc infectate
if(max_infectate < nr_infectate)max_infectate = nr_infectate
#trecem la ziua urmatoare
nr_zile = nr_zile + 1
}
return(max_infectate)
}
prob_infectare_20 = function(n){
counter = 0
for(i in 1:n){
if(infectare() == 20){
counter = counter + 1
}
}
return(counter/n)
}
prob_infectare_8 = function(n){
counter = 0
for(i in 1:n){
if(infectare() >= 8){
counter = counter + 1
}
}
return(counter/n)
}
prob_infectare_20(100)
prob_infectare_8(1+N_minim(0.01,0.95))
normal_density = function(med,sigma_squared,limit){
t = seq(-limit,limit,length = 400)
sig = sqrt(sigma_squared)
f = (1/(sig*sqrt(2*pi)))*exp(-(((t-med)^2)/(2*sigma_squared)))
plot(t,f,type = "l",lwd = 1)
}
normal_density(0,1,6)
selection_mean = function(filename){
x = scan(filename)
return(mean(x))
}
selection_mean("history.txt")
zconfidence_interval = function(n,sample_mean,alfa,sigma_squared){
alfa = 1 - alfa
sigma = sqrt(sigma_squared)
critical_z = qnorm(1-alfa/2,0,1)
a = sample_mean - critical_z * sigma / sqrt(n)
b = sample_mean + critical_z * sigma / sqrt(n)
return(c(a,b))
}
zconfidence_interval(n = 25,sample_mean = 67.53,alfa = 0.9,sigma_squared = 100)
zconfidence_interval(n = 25,sample_mean = 67.53,alfa = 0.9,sigma_squared = 100)
# 3
zconfidence_interval(n = 50,sample_mean = 5,alfa = 0.95,sigma_squared = 0.5^2)
t_conf_interval = function(n,sample_mean,alfa,s){
alfa = 1 - alfa
se = s/sqrt(n)
critical_t = qt(1-alfa/2,n-1)
a = sample_mean - critical_t * se
b = sample_mean + critical_t * se
return(c(a,b))
}
t_conf_interval = function(n,sample_mean,alfa,s){
alfa = 1 - alfa
se = s/sqrt(n)
critical_t = qt(1-alfa/2,n-1)
a = sample_mean - critical_t * se
b = sample_mean + critical_t * se
return(c(a,b))
}
# 2
t_conf_interval(n = 196,sample_mean = 44.65,alfa = 0.99,s = sqrt(2.25))
date = scan("date45.txt")
m_date = mean(date)
s_date = sd(date)
n_date = length(date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.9,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.95,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.99,s = s_date)
t_conf_interval = function(n,sample_mean,alfa,s){
alfa = 1 - alfa
se = s/sqrt(n)
critical_t = qt(1-alfa/2,n-1)
a = sample_mean - critical_t * se
b = sample_mean + critical_t * se
return(c(a,b))
}
# 2
t_conf_interval(n = 196,sample_mean = 44.65,alfa = 0.99,s = sqrt(2.25))
# 5
date = scan("date45.txt")
m_date = mean(date)
s_date = sd(date)
n_date = length(date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.9,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.95,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.99,s = s_date)
setwd("D:/Info/Info_fac/Rstudio/Lab5")
t_conf_interval = function(n,sample_mean,alfa,s){
alfa = 1 - alfa
se = s/sqrt(n)
critical_t = qt(1-alfa/2,n-1)
a = sample_mean - critical_t * se
b = sample_mean + critical_t * se
return(c(a,b))
}
# 2
t_conf_interval(n = 196,sample_mean = 44.65,alfa = 0.99,s = sqrt(2.25))
# 5
date = scan("date45.txt")
m_date = mean(date)
s_date = sd(date)
n_date = length(date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.9,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.95,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.99,s = s_date)
test_proportion = function(n,succese,alfa,p0,tip){
alfa = 1 - alfa
p_prim = succese / n
z_score = (p_prim-p0) / sqrt(p0*(1-p0)/n)
if( tip == 1){
# 1 pentru asimetrica la stanga
critical_z = qnorm(alfa,0,1)
}
else{
if( tip == 2){
# 2 pentru asimetrica la dreapta
critical_z = qnorm(1-alfa,0,1)
}
else{
# altceva pentru simetrica
critical_z = -qnorm(alfa/2,0,1)
}
}
return(c(z_score,critical_z))
}
test_proportion(n = 150,succese = 20,alfa = 0.95,p0 = 0.1,tip = 2)
t_conf_interval = function(n,sample_mean,alfa,s){
alfa = 1 - alfa
se = s/sqrt(n)
critical_t = qt(1-alfa/2,n-1)
a = sample_mean - critical_t * se
b = sample_mean + critical_t * se
return(c(a,b))
}
# 2
t_conf_interval(n = 196,sample_mean = 44.65,alfa = 0.99,s = sqrt(2.25))
# 5
date = scan("date45.txt")
m_date = mean(date)
s_date = sd(date)
n_date = length(date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.9,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.95,s = s_date)
t_conf_interval(n = n_date,sample_mean = m_date,alfa = 0.99,s = s_date)
test_proportion(0.01,42,17,0.25)
