// Copyright (c) 2015-2016 K Team. All Rights Reserved.

// 'allowChainSubsort' is used internally by the rule parser to better control what subsorts
// are allowed to chain with automatic subsorts like K ::= Exp and Exp ::= KBott

// Module defining only the sorts K and KString, useful for modularity
module SORT-K
  syntax K [hook(K.K)]
endmodule

module BASIC-K
  imports SORT-K
  syntax KLabel
  syntax KItem            [hook(K.KItem)]
  syntax K     ::= KItem  [allowChainSubsort]
  syntax KConfigVar
endmodule

module KSTRING
  syntax KString ::= r"[\\\"](([^\\\"\n\r\\\\])|([\\\\][nrtf\\\"\\\\])|([\\\\][x][0-9a-fA-F]{2})|([\\\\][u][0-9a-fA-F]{4})|([\\\\][U][0-9a-fA-F]{8}))*[\\\"]"      [token, hook(org.kframework.kore.KString)]
  // optionally qualified strings, like in Scala "abc", i"abc", r"a*bc", etc.
endmodule

module KAST
  imports BASIC-K
  imports KSTRING
  syntax KBott ::= "#token" "(" KString "," KString ")"  [klabel(#KToken), hook(org.kframework.kore.KToken)]
                 | "#klabel" "(" KLabel ")"              [klabel(#InjectedKLabel), hook(org.kframework.kore.InjectedKLabel)]
                 | KLabel "(" KList ")"                  [klabel(#KApply), hook(org.kframework.kore.KApply)]
  syntax KItem ::= KBott                                 [allowChainSubsort]

  syntax KLabel ::= r"`(\\\\`|\\\\\\\\|[^`\\\\\n\r])+`" [token, hook(org.kframework.kore.KLabel)]
                  | r"(?<![a-zA-Z0-9])[#a-z][a-zA-Z0-9]*"               [token, hook(org.kframework.kore.KLabel), autoReject]
                       // something that doesn't collide with meta-variables

  syntax KList ::= K                 [allowChainSubsort]
                 | ".KList"          [klabel(#EmptyKList), hook(org.kframework.kore.EmptyKList)]
                 | ".::KList"        [klabel(#EmptyKList), hook(org.kframework.kore.EmptyKList)]
                 | KList "," KList   [klabel(#KList), left, assoc, unit(#EmptyKList), hook(org.kframework.kore.KList), prefer]
//TODO(dwightguth): there is some kind of weird issue with this production which is causing AddEmptyLists to behave incorrectly.
// we need to fix this issue so we can add this production back.
//                 | KList ",," KList  [klabel(#KList), left, assoc, unit(#EmptyKList), hook(org.kframework.kore.KList), prefer]
endmodule


// To be used when parsing/pretty-printing ground configurations
module KSEQ
  imports KAST
  imports K-TOP-SORT
  syntax KBott ::= ".K"      [klabel(#EmptyK), hook(org.kframework.kore.EmptyK)]
                 | "."       [klabel(#EmptyK), hook(org.kframework.kore.EmptyK)]
                 | ".::K"    [klabel(#EmptyK), hook(org.kframework.kore.EmptyK)]
                 | K "~>" K  [klabel(#KSequence), left, assoc, unit(#EmptyK), hook(org.kframework.kore.KSequence)]
  syntax left #KSequence
  syntax KBott     ::= "(" K ")"    [bracket]
endmodule


// To be used when parsing/pretty-printing symbolic configurations
module KSEQ-SYMBOLIC
  imports KSEQ
  syntax #KVariable ::= r"(?<![A-Za-z0-9_\\$!\\?])(\\!|\\?)?([A-Z][A-Za-z0-9'_]*|_)"   [token, autoReject, hook(org.kframework.kore.KVariable)]
  syntax KConfigVar ::= r"(?<![A-Za-z0-9_\\$!\\?])(\\$)([A-Z][A-Za-z0-9'_]*)"          [token, autoReject]
  syntax KBott      ::= #KVariable [allowChainSubsort]
  syntax KBott      ::= KConfigVar [allowChainSubsort]
  syntax KLabel     ::= #KVariable [allowChainSubsort]
endmodule

module KCELLS
  imports KAST

  syntax Cell
  syntax Bag ::= Bag Bag  [left, assoc, klabel(#cells), unit(#cells)]
               | ".Bag"   [klabel(#cells)]
               | ".::Bag" [klabel(#cells)]
               | Cell     [allowChainSubsort]
  syntax Bag ::= "(" Bag ")" [bracket]
  syntax K ::= Bag
  syntax Bag ::= KBott
endmodule

module RULE-CELLS
  imports KCELLS
  imports RULE-LISTS
  // if this module is imported, the parser automatically
  // generates, for all productions that have the attribute 'cell' or 'maincell',
  // a production like below:
  //syntax Cell ::= "<top>" #OptionalDots K #OptionalDots "</top>" [klabel(<top>)]

  syntax #OptionalDots ::= "..." [klabel(#dots)]
                         | ""    [klabel(#noDots)]
endmodule

module CONFIG-CELLS
  imports KCELLS
  imports RULE-LISTS
  syntax #CellName ::= r"[a-zA-Z0-9\\-]+"  [token]

  syntax Cell ::= "<" #CellName #CellProperties ">" K "</" #CellName ">" [klabel(#configCell)]
  syntax Cell ::= "<" #CellName "/>" [klabel(#externalCell)]

  syntax #CellProperties ::= #CellProperty #CellProperties [klabel(#cellPropertyList)]
                           | ""                            [klabel(#cellPropertyListTerminator)]
  syntax #CellProperty ::= #CellName "=" KString           [klabel(#cellProperty)]

endmodule


module REQUIRES-ENSURES
  imports BASIC-K

  syntax RuleContent ::= K                                 [klabel("#ruleNoConditions"), allowChainSubsort]
                       | K "requires" K                    [klabel("#ruleRequires")]
                       | K "when" K                        [klabel("#ruleRequires")]
                       | K "ensures"  K                    [klabel("#ruleEnsures")]
                       | K "requires" K "ensures" K        [klabel("#ruleRequiresEnsures")]
                       | K "when" K "ensures" K            [klabel("#ruleRequiresEnsures")]
endmodule

module K-TOP-SORT
  // if this module is imported, the parser automatically
  // generates, for all sorts, productions of the form:
  // K     ::= Sort
  // this is part of the mechanism that allows concrete user syntax in K
endmodule

module K-BOTTOM-SORT
  // if this module is imported, the parser automatically
  // generates, for all sorts, productions of the form:
  // Sort  ::= KBott
  // this is part of the mechanism that allows concrete user syntax in K
endmodule

module K-SORT-LATTICE
  imports K-TOP-SORT
  imports K-BOTTOM-SORT
endmodule

module AUTO-CASTS
  // if this module is imported, the parser automatically
  // generates, for all sorts, productions of the form:
  // Sort  ::= Sort "::Sort"
  // Sort  ::= Sort ":Sort"
  // KBott ::= Sort "<:Sort"
  // Sort  ::= K    ":>Sort"
  // this is part of the mechanism that allows concrete user syntax in K
endmodule

module AUTO-FOLLOW
  // if this module is imported, the parser automatically
  // generates a follow restriction for every terminal which is a prefix
  // of another terminal. This is useful to prevent ambiguities such as:
  // syntax K ::= "a"
  // syntax K ::= "b"
  // syntax K ::= "ab"
  // syntax K ::= K K
  // #parse("ab", "K")
  // In the above example, the terminal "a" is not allowed to be followed by a "b"
  // because it would turn the terminal into the terminal "ab".
endmodule

module PROGRAM-LISTS
  imports SORT-K
  // if this module is imported, the parser automatically
  // replaces the default productions for lists:
  // Es ::= E "," Es [userList("*"), klabel('_,_)]
  //      | ".Es"    [userList("*"), klabel('.Es)]
  // into a series of productions more suitable for programs:
  // Es#Terminator ::= ""      [klabel('.Es)]
  // Ne#Es ::= E "," Ne#Es     [klabel('_,_)]
  //         | E Es#Terminator [klabel('_,_)]
  // Es ::= Ne#Es
  //      | Es#Terminator      // if the list is *
endmodule

module RULE-LISTS
  // if this module is imported, the parser automatically
  // adds the subsort production to the parsing module only:
  // Es ::= E        [userList("*")]

endmodule

module DEFAULT-CONFIGURATION
  imports BASIC-K

  configuration <k> $PGM:K </k>
endmodule

// To be used to parse semantic rules
module K
  imports KSEQ-SYMBOLIC
  imports REQUIRES-ENSURES
  imports K-SORT-LATTICE
  imports AUTO-CASTS
  imports AUTO-FOLLOW
  syntax KBott     ::= K "=>" K     [klabel(#KRewrite), hook(org.kframework.kore.KRewrite), non-assoc]
  syntax non-assoc #KRewrite

endmodule

// To be used to parse terms in full K
module K-TERM
  imports KSEQ-SYMBOLIC
  imports K-SORT-LATTICE
  imports AUTO-CASTS
  imports AUTO-FOLLOW
endmodule
